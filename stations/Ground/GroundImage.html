<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>skyimage.stations.Ground.GroundImage API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skyimage.stations.Ground.GroundImage</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import datetime
import glob
import logging
from typing import Dict
from typing import Optional
from typing import Union
import warnings

import matplotlib.pyplot as plt
import numpy as np
from numpy import ndarray
import pandas as pd
from skimage.io import imread
from skyimage.stations.Ground.utils.image import f_above_or_below
from skyimage.stations.Ground.utils.utils import STDDelta
from skyimage.stations.Sky import SkyScene
from skyimage.utils.utils import Station as StationObject
from skyimage.utils.utils import buffer_value


class GroundImage:
    def __init__(
        self,
        target_time: datetime = None,
        direct_path: Optional[str] = None,
        ground_path: Optional[str] = None,
        station: Union[StationObject, str] = None,
        time_delta: Optional[int] = None,
        file_format: str = &#34;jpg&#34;,
        mask_path: Optional[str] = &#34;skyimage\\stations\\Ground\\mask.npy&#34;,
        show_image: bool = False,
        save_image: bool = False,
    ):
        self.target_time: datetime = target_time
        self.direct_path: str = direct_path
        self.file_format = file_format

        if isinstance(station, StationObject):
            self.station = station
        elif isinstance(station, str):
            self.station = StationObject(name=station)
        else:
            raise ValueError(&#34;`station` must be a str or type Station&#34;)

        if direct_path and ground_path:
            warnings.warn(
                &#34;Both `ground_path and `direct_path` passed,\
                defaulting to `direct_path`&#34;,
                UserWarning,
                stacklevel=2,
            )

            self.direct_path = direct_path
        elif not direct_path:

            assert ground_path, &#34;`ground_path` required when not using `direct_path`&#34;
            assert target_time, &#34;`target_time` required when not using `direct_path`&#34;
            assert station, &#34;`station` required when not using `direct_path&#34;

            self.__find_matching_image(target_time, self.station.name, ground_path)
        else:
            if not time_delta:
                self.time_delta: int = self.time_delta()
            else:
                self.time_delta: int = time_delta

        self.mask_path: bool = mask_path
        self.show_image: bool = show_image
        self.save_image: bool = save_image
        self.processed: bool = False

        self.BI: ndarray
        self.SI: ndarray
        self.BI_stats: dict
        self.SI_stats: dict
        self.n_total: int
        self.prcnt_cld: float

    @property
    def j_day(self) -&gt; str:
        j_day: int = self.target_time.timetuple().tm_yday
        return buffer_value(j_day, 3)

    @property
    def j_day_full(self) -&gt; str:
        j_day: int = self.target_time.timetuple().tm_yday
        year: int = self.target_time.year
        return str(year) + buffer_value(j_day, 3)

    @property
    def name(self) -&gt; str:
        date: str = self.j_day_full
        time: str = str(self.actual_time.strftime(&#34;%H%M&#34;))
        return f&#34;{date}-{time}&#34;

    def __str__(self) -&gt; str:
        self_str: str = f&#34;&#34;&#34;
            {self.name}
            {self.time_delta} second(s) from target
            &#34;&#34;&#34;

        if self.processed:
            self_str = (
                self_str
                + f&#34;&#34;&#34;
                {self.prcnt_cld} % cloudy
                {self.n_total} total pixels
                BI
                {self.BI_stats}
                SI
                {self.SI_stats}
                &#34;&#34;&#34;
            )
        return self_str

    def __repr__(self) -&gt; str:
        return f&#34;&lt;GroundImage {self.name}&gt;&#34;

    def __eq__(self, o: object) -&gt; bool:
        if isinstance(o, SkyScene):
            if o.j_day_full == self.j_day_full:
                return True
        return False

    def time_delta(self) -&gt; int:
        delta = self.actual_time - self.target_time
        return delta.seconds

    @staticmethod
    def __show_image(img: ndarray) -&gt; None:
        plt.imshow(img)
        plt.show()

    @staticmethod
    def __save_image(img: ndarray, file_name: str) -&gt; None:

        plt.imsave(file_name, img.astype(&#34;uint8&#34;))

    def __find_matching_image(
        self, target_time: datetime, station: str, path: str
    ) -&gt; None:
        &#34;&#34;&#34;Find path to desired image

        Uses
        ----------

        `self.file_format` : str
            File format of target image

        Parameters
        ----------

        `target_time` : datetime
            target image time

        `station` : str
            Name of target station

        `path` : str
            Path for image search

        Defines
        ----------
        `self.direct_path`
            path to target image

        `self.actual_time`
            time `direct_path` image was taken

        `self.time_delta`
            time delta in seconds from target time

        &#34;&#34;&#34;
        file_format: str = self.file_format
        year: str = str(target_time.year)
        month: str = buffer_value(target_time.month, 2)
        day: str = buffer_value(target_time.day, 2)

        search_directory: str = f&#34;/{station}/{year}/{month}/{day}/&#34;

        matching_file_list = list(
            glob.iglob(path + f&#34;{search_directory}*{year + month + day}*.{file_format}&#34;)
        )

        if not matching_file_list:
            raise FileNotFoundError(f&#34;GROUND image for {target_time} not found&#34;)

        time_resolver: STDDelta = STDDelta()
        for file in matching_file_list:
            ground_std_idx: int = file.index(year + month + day)
            ground_std = datetime.strptime(
                file[ground_std_idx : ground_std_idx + 15], &#34;%Y%m%dT%H%M%S&#34;
            )
            std_delta = ground_std - target_time
            seconds_delta: int = std_delta.seconds
            time_resolver.min_resolver(ground_std, seconds_delta, file)

        if time_resolver.seconds &gt; 7200:
            warnings.warn(
                f&#34;&#34;&#34;
                GROUND photo
                {time_resolver}
                target: {str(target_time)}
                &#34;&#34;&#34;,
                UserWarning,
                stacklevel=2,
            )

        logging.info(
            f&#34;&#34;&#34;
            GROUND photo
            {time_resolver}
            target: {str(target_time)}
            &#34;&#34;&#34;,
        )
        self.direct_path = time_resolver.path
        self.actual_time = time_resolver.std
        self.time_delta = time_resolver.seconds

    def run_all(
        self,
        show_image: bool = False,
        save_image: Optional[bool] = None,
        show_time: Optional[bool] = None,
    ) -&gt; None:

        start_time: datetime = datetime.now()

        if save_image:
            self.save_image = save_image
        if show_image:
            self.show_image = show_image

        self.extract()
        self.process()

        if show_time:
            print(self.name + &#34;-&#34;, datetime.now() - start_time)

    def extract(self) -&gt; None:
        &#34;&#34;&#34;Extract `BI` and `SI` for image at `self.direct_path`.

        Uses
        ----------

        `self.mask_path` : str
            Path to np.ndarray defining crop mask

        `self.direct_path` : str
            Path to target image

        `self.show_image` : bool
            Boolean determining if target image should
            be displayed

        `self.save_image` : bool
            Boolean determining if target image should
            be saved to disk

        `self.name` : str
            YYYY-JDAY-HH:MM of image

        Defines
        ----------
        `self.BI`
            Brightness Index of image
        `self.SI`
            Sky Index of image

        &#34;&#34;&#34;

        crop_mask: ndarray = np.load(self.mask_path)

        img_arr: ndarray = imread(self.direct_path)

        img: ndarray = img_arr * crop_mask

        if self.show_image:
            self.__show_image(img)

        if self.save_image:
            img_file_name = self.name + &#34;.png&#34;
            self.__save_image(img, img_file_name)

        img: ndarray = img.astype(&#34;float&#34;)
        img[img == 0] = np.nan

        R: ndarray = img[:, :, 0] / 255
        G: ndarray = img[:, :, 1] / 255
        B: ndarray = img[:, :, 2] / 255

        SI: ndarray = (B - R) / (B + R)
        BI: ndarray = (R + G + B) / 3

        self.BI = BI
        self.SI = SI

    def process(self) -&gt; None:
        &#34;&#34;&#34;Process `self.BI` and `self.SI` for image at `self.direct_path`.

        Uses
        ----------
        `self.BI` : ndarray
            Image Brightness index

        `self.SI` : ndarray
            Image Sky Index

        Defines
        ----------
        `self.BI_stats` : dict
            Statistical information
            concerning image

        `self.SI_stats` : dict
            Statistical information
            concerning image

        `self.n_total` : int
            Total pixels in image

        `self.prcnt_cld` : float
            Percent clouds in image

        `self.processed` : bool
            Marker signaling object processed


        &#34;&#34;&#34;

        def __extract_stats(array) -&gt; Dict[str, float]:

            mean = round(np.nanmean(array), 2)
            max = round(np.nanmax(array), 2)
            min = round(np.nanmin(array), 2)

            return {&#34;mean&#34;: mean, &#34;max&#34;: max, &#34;min&#34;: min}

        if not hasattr(self, &#34;BI&#34;) or not hasattr(self, &#34;SI&#34;):
            raise ValueError(
                &#34;GroundImage object must have `BI` and `SI` values before processing&#34;
            )

        # we keep NaNs to preserve image shape
        # for reconstitution after cloud mask creation
        # BI = BI[np.logical_not(np.isnan(BI))]
        # SI = SI[np.logical_not(np.isnan(SI))]

        BI_stats: dict = __extract_stats(self.BI)
        SI_stats: dict = __extract_stats(self.SI)
        BI_SI_points = np.column_stack((self.BI.flatten(), self.SI.flatten()))

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        boundary = np.column_stack((x_step, y_step))

        pixel_total: int = BI_SI_points[np.logical_not(np.isnan(BI_SI_points))].size / 2

        cloud_mask: list = []
        img_shape: tuple = self.BI.shape[0:2]
        number_clear: int = 0

        for point in BI_SI_points:
            results: int = f_above_or_below(point, boundary)
            cloud_mask.append(results)
            number_clear = number_clear + results

        cloud_mask = np.array(cloud_mask).reshape(img_shape)

        if self.show_image:
            self.__show_image(cloud_mask)

        if self.save_image:
            img_file_name = self.name + &#34;_cld_mask.png&#34;
            self.__save_image(cloud_mask, img_file_name)
            self.graph(save=True)

        percent_cloud: float = round(
            ((pixel_total - number_clear) / pixel_total) * 100, 2
        )

        self.BI_stats = BI_stats
        self.SI_stats = SI_stats
        self.n_total = int(pixel_total)
        self.prcnt_cld = percent_cloud
        self.processed = True

    def results(self, as_dataframe: bool = False) -&gt; Union[dict, pd.DataFrame]:

        if not self.processed:
            raise AssertionError(&#34;Object not processed&#34;)

        results = {
            &#34;BI&#34;: self.BI_stats,
            &#34;SI&#34;: self.SI_stats,
            &#34;n_total&#34;: self.n_total,
            &#34;prcnt_cld&#34;: self.prcnt_cld,
            &#34;time&#34;: self.actual_time.strftime(&#34;%H%M&#34;),
            &#34;seconds_delta&#34;: self.time_delta,
        }

        if as_dataframe:
            return pd.DataFrame.from_dict(results, orient=&#34;index&#34;)

        return results

    def graph(self, save: Optional[bool] = False):

        if not hasattr(self, &#34;BI&#34;) or not hasattr(self, &#34;SI&#34;):
            raise ValueError(&#34;GroundImage object must have `BI` and `SI` values&#34;)

        BI: ndarray = self.BI.flatten()
        SI: ndarray = self.SI.flatten()

        x: ndarray = BI[np.logical_not(np.isnan(BI))]
        y: ndarray = SI[np.logical_not(np.isnan(SI))]

        plt.xlabel(&#34;BI&#34;)
        plt.ylabel(&#34;SI&#34;)

        plt.hist2d(x, y, (50, 50), cmap=plt.cm.jet)

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        plt.plot(x_step, y_step, &#34;w&#34;)

        cb = plt.colorbar()

        if save:
            plt.savefig(self.name + &#34;_decision_boundary&#34;, dpi=100)
            # TODO fix
            # one of these works
            cb.remove()
            plt.close()
            plt.close(&#34;all&#34;)
            plt.clf()
            plt.cla()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage"><code class="flex name class">
<span>class <span class="ident">GroundImage</span></span>
<span>(</span><span>target_time: datetime.datetime = None, direct_path: Union[str, NoneType] = None, ground_path: Union[str, NoneType] = None, station: Union[<a title="skyimage.utils.utils.Station" href="../../utils/utils.html#skyimage.utils.utils.Station">Station</a>, str] = None, time_delta: Union[int, NoneType] = None, file_format: str = 'jpg', mask_path: Union[str, NoneType] = 'skyimage\\stations\\Ground\\mask.npy', show_image: bool = False, save_image: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GroundImage:
    def __init__(
        self,
        target_time: datetime = None,
        direct_path: Optional[str] = None,
        ground_path: Optional[str] = None,
        station: Union[StationObject, str] = None,
        time_delta: Optional[int] = None,
        file_format: str = &#34;jpg&#34;,
        mask_path: Optional[str] = &#34;skyimage\\stations\\Ground\\mask.npy&#34;,
        show_image: bool = False,
        save_image: bool = False,
    ):
        self.target_time: datetime = target_time
        self.direct_path: str = direct_path
        self.file_format = file_format

        if isinstance(station, StationObject):
            self.station = station
        elif isinstance(station, str):
            self.station = StationObject(name=station)
        else:
            raise ValueError(&#34;`station` must be a str or type Station&#34;)

        if direct_path and ground_path:
            warnings.warn(
                &#34;Both `ground_path and `direct_path` passed,\
                defaulting to `direct_path`&#34;,
                UserWarning,
                stacklevel=2,
            )

            self.direct_path = direct_path
        elif not direct_path:

            assert ground_path, &#34;`ground_path` required when not using `direct_path`&#34;
            assert target_time, &#34;`target_time` required when not using `direct_path`&#34;
            assert station, &#34;`station` required when not using `direct_path&#34;

            self.__find_matching_image(target_time, self.station.name, ground_path)
        else:
            if not time_delta:
                self.time_delta: int = self.time_delta()
            else:
                self.time_delta: int = time_delta

        self.mask_path: bool = mask_path
        self.show_image: bool = show_image
        self.save_image: bool = save_image
        self.processed: bool = False

        self.BI: ndarray
        self.SI: ndarray
        self.BI_stats: dict
        self.SI_stats: dict
        self.n_total: int
        self.prcnt_cld: float

    @property
    def j_day(self) -&gt; str:
        j_day: int = self.target_time.timetuple().tm_yday
        return buffer_value(j_day, 3)

    @property
    def j_day_full(self) -&gt; str:
        j_day: int = self.target_time.timetuple().tm_yday
        year: int = self.target_time.year
        return str(year) + buffer_value(j_day, 3)

    @property
    def name(self) -&gt; str:
        date: str = self.j_day_full
        time: str = str(self.actual_time.strftime(&#34;%H%M&#34;))
        return f&#34;{date}-{time}&#34;

    def __str__(self) -&gt; str:
        self_str: str = f&#34;&#34;&#34;
            {self.name}
            {self.time_delta} second(s) from target
            &#34;&#34;&#34;

        if self.processed:
            self_str = (
                self_str
                + f&#34;&#34;&#34;
                {self.prcnt_cld} % cloudy
                {self.n_total} total pixels
                BI
                {self.BI_stats}
                SI
                {self.SI_stats}
                &#34;&#34;&#34;
            )
        return self_str

    def __repr__(self) -&gt; str:
        return f&#34;&lt;GroundImage {self.name}&gt;&#34;

    def __eq__(self, o: object) -&gt; bool:
        if isinstance(o, SkyScene):
            if o.j_day_full == self.j_day_full:
                return True
        return False

    def time_delta(self) -&gt; int:
        delta = self.actual_time - self.target_time
        return delta.seconds

    @staticmethod
    def __show_image(img: ndarray) -&gt; None:
        plt.imshow(img)
        plt.show()

    @staticmethod
    def __save_image(img: ndarray, file_name: str) -&gt; None:

        plt.imsave(file_name, img.astype(&#34;uint8&#34;))

    def __find_matching_image(
        self, target_time: datetime, station: str, path: str
    ) -&gt; None:
        &#34;&#34;&#34;Find path to desired image

        Uses
        ----------

        `self.file_format` : str
            File format of target image

        Parameters
        ----------

        `target_time` : datetime
            target image time

        `station` : str
            Name of target station

        `path` : str
            Path for image search

        Defines
        ----------
        `self.direct_path`
            path to target image

        `self.actual_time`
            time `direct_path` image was taken

        `self.time_delta`
            time delta in seconds from target time

        &#34;&#34;&#34;
        file_format: str = self.file_format
        year: str = str(target_time.year)
        month: str = buffer_value(target_time.month, 2)
        day: str = buffer_value(target_time.day, 2)

        search_directory: str = f&#34;/{station}/{year}/{month}/{day}/&#34;

        matching_file_list = list(
            glob.iglob(path + f&#34;{search_directory}*{year + month + day}*.{file_format}&#34;)
        )

        if not matching_file_list:
            raise FileNotFoundError(f&#34;GROUND image for {target_time} not found&#34;)

        time_resolver: STDDelta = STDDelta()
        for file in matching_file_list:
            ground_std_idx: int = file.index(year + month + day)
            ground_std = datetime.strptime(
                file[ground_std_idx : ground_std_idx + 15], &#34;%Y%m%dT%H%M%S&#34;
            )
            std_delta = ground_std - target_time
            seconds_delta: int = std_delta.seconds
            time_resolver.min_resolver(ground_std, seconds_delta, file)

        if time_resolver.seconds &gt; 7200:
            warnings.warn(
                f&#34;&#34;&#34;
                GROUND photo
                {time_resolver}
                target: {str(target_time)}
                &#34;&#34;&#34;,
                UserWarning,
                stacklevel=2,
            )

        logging.info(
            f&#34;&#34;&#34;
            GROUND photo
            {time_resolver}
            target: {str(target_time)}
            &#34;&#34;&#34;,
        )
        self.direct_path = time_resolver.path
        self.actual_time = time_resolver.std
        self.time_delta = time_resolver.seconds

    def run_all(
        self,
        show_image: bool = False,
        save_image: Optional[bool] = None,
        show_time: Optional[bool] = None,
    ) -&gt; None:

        start_time: datetime = datetime.now()

        if save_image:
            self.save_image = save_image
        if show_image:
            self.show_image = show_image

        self.extract()
        self.process()

        if show_time:
            print(self.name + &#34;-&#34;, datetime.now() - start_time)

    def extract(self) -&gt; None:
        &#34;&#34;&#34;Extract `BI` and `SI` for image at `self.direct_path`.

        Uses
        ----------

        `self.mask_path` : str
            Path to np.ndarray defining crop mask

        `self.direct_path` : str
            Path to target image

        `self.show_image` : bool
            Boolean determining if target image should
            be displayed

        `self.save_image` : bool
            Boolean determining if target image should
            be saved to disk

        `self.name` : str
            YYYY-JDAY-HH:MM of image

        Defines
        ----------
        `self.BI`
            Brightness Index of image
        `self.SI`
            Sky Index of image

        &#34;&#34;&#34;

        crop_mask: ndarray = np.load(self.mask_path)

        img_arr: ndarray = imread(self.direct_path)

        img: ndarray = img_arr * crop_mask

        if self.show_image:
            self.__show_image(img)

        if self.save_image:
            img_file_name = self.name + &#34;.png&#34;
            self.__save_image(img, img_file_name)

        img: ndarray = img.astype(&#34;float&#34;)
        img[img == 0] = np.nan

        R: ndarray = img[:, :, 0] / 255
        G: ndarray = img[:, :, 1] / 255
        B: ndarray = img[:, :, 2] / 255

        SI: ndarray = (B - R) / (B + R)
        BI: ndarray = (R + G + B) / 3

        self.BI = BI
        self.SI = SI

    def process(self) -&gt; None:
        &#34;&#34;&#34;Process `self.BI` and `self.SI` for image at `self.direct_path`.

        Uses
        ----------
        `self.BI` : ndarray
            Image Brightness index

        `self.SI` : ndarray
            Image Sky Index

        Defines
        ----------
        `self.BI_stats` : dict
            Statistical information
            concerning image

        `self.SI_stats` : dict
            Statistical information
            concerning image

        `self.n_total` : int
            Total pixels in image

        `self.prcnt_cld` : float
            Percent clouds in image

        `self.processed` : bool
            Marker signaling object processed


        &#34;&#34;&#34;

        def __extract_stats(array) -&gt; Dict[str, float]:

            mean = round(np.nanmean(array), 2)
            max = round(np.nanmax(array), 2)
            min = round(np.nanmin(array), 2)

            return {&#34;mean&#34;: mean, &#34;max&#34;: max, &#34;min&#34;: min}

        if not hasattr(self, &#34;BI&#34;) or not hasattr(self, &#34;SI&#34;):
            raise ValueError(
                &#34;GroundImage object must have `BI` and `SI` values before processing&#34;
            )

        # we keep NaNs to preserve image shape
        # for reconstitution after cloud mask creation
        # BI = BI[np.logical_not(np.isnan(BI))]
        # SI = SI[np.logical_not(np.isnan(SI))]

        BI_stats: dict = __extract_stats(self.BI)
        SI_stats: dict = __extract_stats(self.SI)
        BI_SI_points = np.column_stack((self.BI.flatten(), self.SI.flatten()))

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        boundary = np.column_stack((x_step, y_step))

        pixel_total: int = BI_SI_points[np.logical_not(np.isnan(BI_SI_points))].size / 2

        cloud_mask: list = []
        img_shape: tuple = self.BI.shape[0:2]
        number_clear: int = 0

        for point in BI_SI_points:
            results: int = f_above_or_below(point, boundary)
            cloud_mask.append(results)
            number_clear = number_clear + results

        cloud_mask = np.array(cloud_mask).reshape(img_shape)

        if self.show_image:
            self.__show_image(cloud_mask)

        if self.save_image:
            img_file_name = self.name + &#34;_cld_mask.png&#34;
            self.__save_image(cloud_mask, img_file_name)
            self.graph(save=True)

        percent_cloud: float = round(
            ((pixel_total - number_clear) / pixel_total) * 100, 2
        )

        self.BI_stats = BI_stats
        self.SI_stats = SI_stats
        self.n_total = int(pixel_total)
        self.prcnt_cld = percent_cloud
        self.processed = True

    def results(self, as_dataframe: bool = False) -&gt; Union[dict, pd.DataFrame]:

        if not self.processed:
            raise AssertionError(&#34;Object not processed&#34;)

        results = {
            &#34;BI&#34;: self.BI_stats,
            &#34;SI&#34;: self.SI_stats,
            &#34;n_total&#34;: self.n_total,
            &#34;prcnt_cld&#34;: self.prcnt_cld,
            &#34;time&#34;: self.actual_time.strftime(&#34;%H%M&#34;),
            &#34;seconds_delta&#34;: self.time_delta,
        }

        if as_dataframe:
            return pd.DataFrame.from_dict(results, orient=&#34;index&#34;)

        return results

    def graph(self, save: Optional[bool] = False):

        if not hasattr(self, &#34;BI&#34;) or not hasattr(self, &#34;SI&#34;):
            raise ValueError(&#34;GroundImage object must have `BI` and `SI` values&#34;)

        BI: ndarray = self.BI.flatten()
        SI: ndarray = self.SI.flatten()

        x: ndarray = BI[np.logical_not(np.isnan(BI))]
        y: ndarray = SI[np.logical_not(np.isnan(SI))]

        plt.xlabel(&#34;BI&#34;)
        plt.ylabel(&#34;SI&#34;)

        plt.hist2d(x, y, (50, 50), cmap=plt.cm.jet)

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        plt.plot(x_step, y_step, &#34;w&#34;)

        cb = plt.colorbar()

        if save:
            plt.savefig(self.name + &#34;_decision_boundary&#34;, dpi=100)
            # TODO fix
            # one of these works
            cb.remove()
            plt.close()
            plt.close(&#34;all&#34;)
            plt.clf()
            plt.cla()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.j_day"><code class="name">var <span class="ident">j_day</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j_day(self) -&gt; str:
    j_day: int = self.target_time.timetuple().tm_yday
    return buffer_value(j_day, 3)</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.j_day_full"><code class="name">var <span class="ident">j_day_full</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j_day_full(self) -&gt; str:
    j_day: int = self.target_time.timetuple().tm_yday
    year: int = self.target_time.year
    return str(year) + buffer_value(j_day, 3)</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    date: str = self.j_day_full
    time: str = str(self.actual_time.strftime(&#34;%H%M&#34;))
    return f&#34;{date}-{time}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Extract <code>BI</code> and <code>SI</code> for image at <code>self.direct_path</code>.</p>
<h2 id="uses">Uses</h2>
<p><code>self.mask_path</code> : str
Path to np.ndarray defining crop mask</p>
<p><code>self.direct_path</code> : str
Path to target image</p>
<p><code>self.show_image</code> : bool
Boolean determining if target image should
be displayed</p>
<p><code>self.save_image</code> : bool
Boolean determining if target image should
be saved to disk</p>
<p><code>self.name</code> : str
YYYY-JDAY-HH:MM of image</p>
<h2 id="defines">Defines</h2>
<p><code>self.BI</code>
Brightness Index of image
<code>self.SI</code>
Sky Index of image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self) -&gt; None:
    &#34;&#34;&#34;Extract `BI` and `SI` for image at `self.direct_path`.

    Uses
    ----------

    `self.mask_path` : str
        Path to np.ndarray defining crop mask

    `self.direct_path` : str
        Path to target image

    `self.show_image` : bool
        Boolean determining if target image should
        be displayed

    `self.save_image` : bool
        Boolean determining if target image should
        be saved to disk

    `self.name` : str
        YYYY-JDAY-HH:MM of image

    Defines
    ----------
    `self.BI`
        Brightness Index of image
    `self.SI`
        Sky Index of image

    &#34;&#34;&#34;

    crop_mask: ndarray = np.load(self.mask_path)

    img_arr: ndarray = imread(self.direct_path)

    img: ndarray = img_arr * crop_mask

    if self.show_image:
        self.__show_image(img)

    if self.save_image:
        img_file_name = self.name + &#34;.png&#34;
        self.__save_image(img, img_file_name)

    img: ndarray = img.astype(&#34;float&#34;)
    img[img == 0] = np.nan

    R: ndarray = img[:, :, 0] / 255
    G: ndarray = img[:, :, 1] / 255
    B: ndarray = img[:, :, 2] / 255

    SI: ndarray = (B - R) / (B + R)
    BI: ndarray = (R + G + B) / 3

    self.BI = BI
    self.SI = SI</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.graph"><code class="name flex">
<span>def <span class="ident">graph</span></span>(<span>self, save: Union[bool, NoneType] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph(self, save: Optional[bool] = False):

    if not hasattr(self, &#34;BI&#34;) or not hasattr(self, &#34;SI&#34;):
        raise ValueError(&#34;GroundImage object must have `BI` and `SI` values&#34;)

    BI: ndarray = self.BI.flatten()
    SI: ndarray = self.SI.flatten()

    x: ndarray = BI[np.logical_not(np.isnan(BI))]
    y: ndarray = SI[np.logical_not(np.isnan(SI))]

    plt.xlabel(&#34;BI&#34;)
    plt.ylabel(&#34;SI&#34;)

    plt.hist2d(x, y, (50, 50), cmap=plt.cm.jet)

    x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
    y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
    plt.plot(x_step, y_step, &#34;w&#34;)

    cb = plt.colorbar()

    if save:
        plt.savefig(self.name + &#34;_decision_boundary&#34;, dpi=100)
        # TODO fix
        # one of these works
        cb.remove()
        plt.close()
        plt.close(&#34;all&#34;)
        plt.clf()
        plt.cla()</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Process <code>self.BI</code> and <code>self.SI</code> for image at <code>self.direct_path</code>.</p>
<h2 id="uses">Uses</h2>
<p><code>self.BI</code> : ndarray
Image Brightness index</p>
<p><code>self.SI</code> : ndarray
Image Sky Index</p>
<h2 id="defines">Defines</h2>
<p><code>self.BI_stats</code> : dict
Statistical information
concerning image</p>
<p><code>self.SI_stats</code> : dict
Statistical information
concerning image</p>
<p><code>self.n_total</code> : int
Total pixels in image</p>
<p><code>self.prcnt_cld</code> : float
Percent clouds in image</p>
<p><code>self.processed</code> : bool
Marker signaling object processed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self) -&gt; None:
    &#34;&#34;&#34;Process `self.BI` and `self.SI` for image at `self.direct_path`.

    Uses
    ----------
    `self.BI` : ndarray
        Image Brightness index

    `self.SI` : ndarray
        Image Sky Index

    Defines
    ----------
    `self.BI_stats` : dict
        Statistical information
        concerning image

    `self.SI_stats` : dict
        Statistical information
        concerning image

    `self.n_total` : int
        Total pixels in image

    `self.prcnt_cld` : float
        Percent clouds in image

    `self.processed` : bool
        Marker signaling object processed


    &#34;&#34;&#34;

    def __extract_stats(array) -&gt; Dict[str, float]:

        mean = round(np.nanmean(array), 2)
        max = round(np.nanmax(array), 2)
        min = round(np.nanmin(array), 2)

        return {&#34;mean&#34;: mean, &#34;max&#34;: max, &#34;min&#34;: min}

    if not hasattr(self, &#34;BI&#34;) or not hasattr(self, &#34;SI&#34;):
        raise ValueError(
            &#34;GroundImage object must have `BI` and `SI` values before processing&#34;
        )

    # we keep NaNs to preserve image shape
    # for reconstitution after cloud mask creation
    # BI = BI[np.logical_not(np.isnan(BI))]
    # SI = SI[np.logical_not(np.isnan(SI))]

    BI_stats: dict = __extract_stats(self.BI)
    SI_stats: dict = __extract_stats(self.SI)
    BI_SI_points = np.column_stack((self.BI.flatten(), self.SI.flatten()))

    x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
    y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
    boundary = np.column_stack((x_step, y_step))

    pixel_total: int = BI_SI_points[np.logical_not(np.isnan(BI_SI_points))].size / 2

    cloud_mask: list = []
    img_shape: tuple = self.BI.shape[0:2]
    number_clear: int = 0

    for point in BI_SI_points:
        results: int = f_above_or_below(point, boundary)
        cloud_mask.append(results)
        number_clear = number_clear + results

    cloud_mask = np.array(cloud_mask).reshape(img_shape)

    if self.show_image:
        self.__show_image(cloud_mask)

    if self.save_image:
        img_file_name = self.name + &#34;_cld_mask.png&#34;
        self.__save_image(cloud_mask, img_file_name)
        self.graph(save=True)

    percent_cloud: float = round(
        ((pixel_total - number_clear) / pixel_total) * 100, 2
    )

    self.BI_stats = BI_stats
    self.SI_stats = SI_stats
    self.n_total = int(pixel_total)
    self.prcnt_cld = percent_cloud
    self.processed = True</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.results"><code class="name flex">
<span>def <span class="ident">results</span></span>(<span>self, as_dataframe: bool = False) ‑> Union[dict, pandas.core.frame.DataFrame]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def results(self, as_dataframe: bool = False) -&gt; Union[dict, pd.DataFrame]:

    if not self.processed:
        raise AssertionError(&#34;Object not processed&#34;)

    results = {
        &#34;BI&#34;: self.BI_stats,
        &#34;SI&#34;: self.SI_stats,
        &#34;n_total&#34;: self.n_total,
        &#34;prcnt_cld&#34;: self.prcnt_cld,
        &#34;time&#34;: self.actual_time.strftime(&#34;%H%M&#34;),
        &#34;seconds_delta&#34;: self.time_delta,
    }

    if as_dataframe:
        return pd.DataFrame.from_dict(results, orient=&#34;index&#34;)

    return results</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.run_all"><code class="name flex">
<span>def <span class="ident">run_all</span></span>(<span>self, show_image: bool = False, save_image: Union[bool, NoneType] = None, show_time: Union[bool, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_all(
    self,
    show_image: bool = False,
    save_image: Optional[bool] = None,
    show_time: Optional[bool] = None,
) -&gt; None:

    start_time: datetime = datetime.now()

    if save_image:
        self.save_image = save_image
    if show_image:
        self.show_image = show_image

    self.extract()
    self.process()

    if show_time:
        print(self.name + &#34;-&#34;, datetime.now() - start_time)</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.GroundImage.GroundImage.time_delta"><code class="name flex">
<span>def <span class="ident">time_delta</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_delta(self) -&gt; int:
    delta = self.actual_time - self.target_time
    return delta.seconds</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skyimage.stations.Ground" href="index.html">skyimage.stations.Ground</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skyimage.stations.Ground.GroundImage.GroundImage" href="#skyimage.stations.Ground.GroundImage.GroundImage">GroundImage</a></code></h4>
<ul class="two-column">
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.extract" href="#skyimage.stations.Ground.GroundImage.GroundImage.extract">extract</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.graph" href="#skyimage.stations.Ground.GroundImage.GroundImage.graph">graph</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.j_day" href="#skyimage.stations.Ground.GroundImage.GroundImage.j_day">j_day</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.j_day_full" href="#skyimage.stations.Ground.GroundImage.GroundImage.j_day_full">j_day_full</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.name" href="#skyimage.stations.Ground.GroundImage.GroundImage.name">name</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.process" href="#skyimage.stations.Ground.GroundImage.GroundImage.process">process</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.results" href="#skyimage.stations.Ground.GroundImage.GroundImage.results">results</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.run_all" href="#skyimage.stations.Ground.GroundImage.GroundImage.run_all">run_all</a></code></li>
<li><code><a title="skyimage.stations.Ground.GroundImage.GroundImage.time_delta" href="#skyimage.stations.Ground.GroundImage.GroundImage.time_delta">time_delta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>