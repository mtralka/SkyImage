<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>skyimage.stations.Ground.Ground API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skyimage.stations.Ground.Ground</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
from typing import Dict
from typing import List
from typing import Optional
from typing import Union
import warnings

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from skyimage.stations.Ground.utils.image import calc_BI
from skyimage.stations.Ground.utils.image import calc_SI
from skyimage.stations.Ground.utils.image import extract_color_bands
from skyimage.stations.Ground.utils.image import extract_stats
from skyimage.stations.Ground.utils.image import f_above_or_below
from skyimage.stations.Ground.utils.image import open_image
from skyimage.stations.Ground.utils.image import open_mask
from skyimage.stations.Ground.utils.image import save_image
from skyimage.stations.Ground.utils.image import show_image

#  from skyimage.stations.Ground.utils.validators import validate_target_time
from skyimage.utils.models import Stations
from skyimage.utils.utils import buffer_value
from skyimage.utils.validators import validate_coords
from skyimage.utils.validators import validate_datetime
from skyimage.utils.validators import validate_file_path
from skyimage.utils.validators import validate_modis_target_sublayers
from skyimage.utils.validators import validate_station_positions


class Ground:
    &#34;&#34;&#34;
    Object with data from the MODIS platform

    ...

    Attributes
    ----------
    path : str
        File path to platform data

    station_positions : dict
        Dict of all possible station positions

    station_name : str
        Name of target station

    coords: List of float
        Spatial coordinates of `station`

    j_day : list of str
        Julian days to extract data for

    file_format : str
        File format of parent file to `target_sublayers`

    year: int
        Year to extract data for

    stds : list of datetime
        Datetime objects to extract data for

    save_images: bool
        Boolean for saving photo and cloud mask results

    show_images: bool
        Boolean for showing photo and cloud mask results

    Methods
    -------
    results
        return process results

    &#34;&#34;&#34;

    def __init__(
        self,
        j_day: Union[int, str, list] = None,
        year: int = None,
        path: str = None,
        coords: Optional[List[float]] = None,
        station: Optional[str] = None,
        file_format: Optional[str] = &#34;jpg&#34;,
        station_positions: Stations = None,
        stds: Optional[dict] = None,
        target_time: Optional[str] = None,
        save_images: Optional[bool] = None,
        show_images: Optional[bool] = None,
    ):

        self.path: str = validate_file_path(path, &#34;GROUND&#34;)
        self.station_positions: Stations = validate_station_positions(station_positions)
        self.station_name: str = station
        self.coords: List[float, float] = validate_coords(
            coords, station, self.station_positions
        )

        if j_day:
            if not target_time:
                warnings.warn(
                    &#34;No `target_time` set, defaulting to 12:00&#34;,
                    UserWarning,
                    stacklevel=2,
                )

                target_time = &#34;12:00&#34;

            self.j_days, self.stds = validate_datetime(j_day, year)
            hour, minute = target_time.split(&#34;:&#34;)

            stds_dict = {}

            for std in self.stds:
                j_day = buffer_value(std.timetuple().tm_yday, 3)
                stds_dict[str(std.year) + j_day] = std.replace(
                    hour=int(hour), minute=int(minute)
                )

            self.stds = stds_dict

        elif stds:
            self.stds = stds
            self.j_days = []

            for j_day in self.stds.keys():
                self.j_days.append(j_day[-3:])

        else:
            raise ValueError(&#34;Must provide j_day + year or stds&#34;)

        self.crop_mask = open_mask()
        self.file_format: str = file_format
        self.target_time = target_time
        self.save_images: bool = save_images
        self.show_images: bool = show_images
        self.images: Dict[str, str] = self.find_matching_images()
        self.raw_poi: Dict[str, Dict[str, object]] = {
            k: self.extract_poi_data(k, v) for k, v in self.images.items()
        }
        self.poi: Dict[str, dict] = {
            k: self.process_poi_data(k, v) for k, v in self.raw_poi.items()
        }

    def __str__(self):

        return f&#34;&#34;&#34;
        Ground platform
        --------
        Data Path : {self.path}
        File Format : {self.file_format}
        Target Sublayers : {self.target_sublayers}
        --------
        Station : {self.station_name}
        Coords : {self.coords}
        Year : {self.stds[0].year}
        Julian Days : {self.j_days[0]} - {self.j_days[-1]}

        {len(self.scenes)} scenes found

        INFO
        --------
        {self.poi}
        &#34;&#34;&#34;

    def find_matching_images(self) -&gt; Dict:
        &#34;&#34;&#34;Find images matching class variables

        Parameters
        ----------
        year : str
            Year of target scenes.

        stds : dict of str
            Dict of target datetimes

        path : str
            Path to image directory

        file_format : str
            File format of target scenes

        station_name : str
            Name of target station

        Returns
        ----------
        Dict
            [ year + Julian day : image file path]

        Raises
        ----------
        FileNotFoundError
            If no files match input paramters

        &#34;&#34;&#34;

        path: str = self.path
        station_name: str = self.station_name
        file_format: str = self.file_format
        target_stds: dict = self.stds
        matching_images: dict = {}

        for k, std in target_stds.items():

            user_selection = 0

            year = str(std.year)
            month = buffer_value(std.month, 2)
            day = buffer_value(std.day, 2)
            #  j_day = buffer_value(std.timetuple().tm_yday, 3)
            hour = buffer_value(std.hour, 2)
            minute = buffer_value(std.minute, 2)

            matching_file_list = list(
                glob.iglob(
                    path
                    + f&#34;/{station_name}/{year}/{month}/{day}/*{year + month + day}*{hour + minute}*.{file_format}&#34;
                )
            )

            if not matching_file_list:
                raise FileNotFoundError(
                    f&#34;GROUND image {year}-{month}-{day}-{hour}:{minute} not found&#34;
                )
                # TODO implement match closest
            elif len(matching_file_list) &gt; 1:
                # TODO present use selection
                #  for index, file in enumerate(matching_file_list):
                #     print(f&#34;{index} | {file}&#34;)
                #  user_selection = int(input(&#34;Which file would you like?&#34;))
                raise LookupError(&#34;Multiple matching files found&#34;)

            logging.info(f&#34;GROUND scene {std} found&#34;)

            matching_images[k] = matching_file_list[user_selection]

        return matching_images

    def extract_poi_data(self, image_name: str, image_path: str) -&gt; dict:
        &#34;&#34;&#34;Extract `BI` and `SI` for image at `image_path`.

        Parameters
        ----------
        image_path : str
            path to image `C:\\path\\to\\image`

        Returns
        ----------
        Dict
            [ BI : BI_array, SI : SI_array ]

        &#34;&#34;&#34;

        crop_mask = self.crop_mask

        img_arr = open_image(image_path)

        img = img_arr * crop_mask

        if self.show_images:
            show_image(img)

        if self.save_images:
            img_file_name = image_name + &#34;.png&#34;
            save_image(img_file_name, img.astype(&#34;uint8&#34;))

        img = img.astype(&#34;float&#34;)
        img[img == 0] = np.nan

        R, G, B = extract_color_bands(img)

        SI = calc_SI(R, B)
        BI = calc_BI(R, G, B)

        return {&#34;BI&#34;: BI, &#34;SI&#34;: SI}

    def process_poi_data(self, image_name: str, raw_data: dict) -&gt; dict:
        &#34;&#34;&#34;Process image

        Parameters
        ----------
        raw_data : Dict[ BI : BI_array, SI : SI_array ]
            Dict containing `BI` and `SI` statistics
            as extracted with `extract_poi_data()`

        Returns
        ----------
        Dict: [ BI : BI_stats, SI : SI_stats ]
            Dict with statistics


        &#34;&#34;&#34;

        BI = raw_data[&#34;BI&#34;]
        SI = raw_data[&#34;SI&#34;]

        # we keep NaNs to preserve image shape
        # for reconstitution after cloud mask creation
        # BI = BI[np.logical_not(np.isnan(BI))]
        # SI = SI[np.logical_not(np.isnan(SI))]

        BI_stats: dict = extract_stats(BI)
        SI_stats: dict = extract_stats(SI)
        BI_SI_points = np.column_stack((BI.flatten(), SI.flatten()))

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        boundary = np.column_stack((x_step, y_step))

        pixel_total: int = BI_SI_points[np.logical_not(np.isnan(BI_SI_points))].size / 2

        cloud_mask: list = []
        img_shape: tuple = BI.shape[0:2]
        number_clear: int = 0

        for point in BI_SI_points:
            results: int = f_above_or_below(point, boundary)
            cloud_mask.append(results)
            number_clear = number_clear + results

        cloud_mask = np.array(cloud_mask).reshape(img_shape)

        if self.show_images:
            show_image(cloud_mask)

        if self.save_images:
            img_file_name = image_name + &#34;_cld_mask.png&#34;
            save_image(img_file_name, cloud_mask)

        percent_cloud: float = round(
            ((pixel_total - number_clear) / pixel_total) * 100, 2
        )

        return {
            &#34;BI&#34;: BI_stats,
            &#34;SI&#34;: SI_stats,
            &#34;n_TOTAL&#34;: pixel_total,
            &#34;prcnt_CLD&#34;: percent_cloud,
        }

    def results(self, as_dataframe: Optional[bool] = True):
        &#34;&#34;&#34;Get processed results

        Parameters
        ----------
        as_dataframe : bool
            return as pandas dataframe

        Returns
        ----------
        Dict : dict
            results as Dict

        &#34;&#34;&#34;

        if as_dataframe:
            return pd.DataFrame.from_dict(self.poi, orient=&#34;index&#34;)

        return self.poi

    @staticmethod
    def show_graph(
        poi: dict = None,
        BI=None,
        SI=None,
        save: Optional[bool] = None,
        file_name: Optional[str] = None,
    ):

        if poi:
            BI = poi[&#34;BI&#34;]
            SI = poi[&#34;SI&#34;]
        elif not BI and not SI:
            raise TypeError(&#34;Require poi Dict [&#39;BI&#39; : array, &#39;SI&#39;: array ] or BI / SI&#34;)

        BI = BI.flatten()
        SI = SI.flatten()

        x = BI[np.logical_not(np.isnan(BI))]
        y = SI[np.logical_not(np.isnan(SI))]

        plt.xlabel(&#34;BI&#34;)
        plt.ylabel(&#34;SI&#34;)

        plt.hist2d(x, y, (50, 50), cmap=plt.cm.jet)

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        plt.plot(x_step, y_step, &#34;w&#34;)

        cb = plt.colorbar()

        if save:
            plt.savefig(file_name, dpi=100)

        # TODO fix
        # one of these works
        cb.remove()
        plt.close()
        plt.close(&#34;all&#34;)
        plt.clf()
        plt.cla()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skyimage.stations.Ground.Ground.Ground"><code class="flex name class">
<span>class <span class="ident">Ground</span></span>
<span>(</span><span>j_day: Union[int, str, list] = None, year: int = None, path: str = None, coords: Union[List[float], NoneType] = None, station: Union[str, NoneType] = None, file_format: Union[str, NoneType] = 'jpg', station_positions: Dict[str, Dict[str, float]] = None, stds: Union[dict, NoneType] = None, target_time: Union[str, NoneType] = None, save_images: Union[bool, NoneType] = None, show_images: Union[bool, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object with data from the MODIS platform</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>File path to platform data</dd>
<dt><strong><code>station_positions</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict of all possible station positions</dd>
<dt><strong><code>station_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of target station</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>List</code> of <code>float</code></dt>
<dd>Spatial coordinates of <code>station</code></dd>
<dt><strong><code>j_day</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Julian days to extract data for</dd>
<dt><strong><code>file_format</code></strong> :&ensp;<code>str</code></dt>
<dd>File format of parent file to <code>target_sublayers</code></dd>
<dt><strong><code>year</code></strong> :&ensp;<code>int</code></dt>
<dd>Year to extract data for</dd>
<dt><strong><code>stds</code></strong> :&ensp;<code>list</code> of <code>datetime</code></dt>
<dd>Datetime objects to extract data for</dd>
<dt><strong><code>save_images</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean for saving photo and cloud mask results</dd>
<dt><strong><code>show_images</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean for showing photo and cloud mask results</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>results
return process results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ground:
    &#34;&#34;&#34;
    Object with data from the MODIS platform

    ...

    Attributes
    ----------
    path : str
        File path to platform data

    station_positions : dict
        Dict of all possible station positions

    station_name : str
        Name of target station

    coords: List of float
        Spatial coordinates of `station`

    j_day : list of str
        Julian days to extract data for

    file_format : str
        File format of parent file to `target_sublayers`

    year: int
        Year to extract data for

    stds : list of datetime
        Datetime objects to extract data for

    save_images: bool
        Boolean for saving photo and cloud mask results

    show_images: bool
        Boolean for showing photo and cloud mask results

    Methods
    -------
    results
        return process results

    &#34;&#34;&#34;

    def __init__(
        self,
        j_day: Union[int, str, list] = None,
        year: int = None,
        path: str = None,
        coords: Optional[List[float]] = None,
        station: Optional[str] = None,
        file_format: Optional[str] = &#34;jpg&#34;,
        station_positions: Stations = None,
        stds: Optional[dict] = None,
        target_time: Optional[str] = None,
        save_images: Optional[bool] = None,
        show_images: Optional[bool] = None,
    ):

        self.path: str = validate_file_path(path, &#34;GROUND&#34;)
        self.station_positions: Stations = validate_station_positions(station_positions)
        self.station_name: str = station
        self.coords: List[float, float] = validate_coords(
            coords, station, self.station_positions
        )

        if j_day:
            if not target_time:
                warnings.warn(
                    &#34;No `target_time` set, defaulting to 12:00&#34;,
                    UserWarning,
                    stacklevel=2,
                )

                target_time = &#34;12:00&#34;

            self.j_days, self.stds = validate_datetime(j_day, year)
            hour, minute = target_time.split(&#34;:&#34;)

            stds_dict = {}

            for std in self.stds:
                j_day = buffer_value(std.timetuple().tm_yday, 3)
                stds_dict[str(std.year) + j_day] = std.replace(
                    hour=int(hour), minute=int(minute)
                )

            self.stds = stds_dict

        elif stds:
            self.stds = stds
            self.j_days = []

            for j_day in self.stds.keys():
                self.j_days.append(j_day[-3:])

        else:
            raise ValueError(&#34;Must provide j_day + year or stds&#34;)

        self.crop_mask = open_mask()
        self.file_format: str = file_format
        self.target_time = target_time
        self.save_images: bool = save_images
        self.show_images: bool = show_images
        self.images: Dict[str, str] = self.find_matching_images()
        self.raw_poi: Dict[str, Dict[str, object]] = {
            k: self.extract_poi_data(k, v) for k, v in self.images.items()
        }
        self.poi: Dict[str, dict] = {
            k: self.process_poi_data(k, v) for k, v in self.raw_poi.items()
        }

    def __str__(self):

        return f&#34;&#34;&#34;
        Ground platform
        --------
        Data Path : {self.path}
        File Format : {self.file_format}
        Target Sublayers : {self.target_sublayers}
        --------
        Station : {self.station_name}
        Coords : {self.coords}
        Year : {self.stds[0].year}
        Julian Days : {self.j_days[0]} - {self.j_days[-1]}

        {len(self.scenes)} scenes found

        INFO
        --------
        {self.poi}
        &#34;&#34;&#34;

    def find_matching_images(self) -&gt; Dict:
        &#34;&#34;&#34;Find images matching class variables

        Parameters
        ----------
        year : str
            Year of target scenes.

        stds : dict of str
            Dict of target datetimes

        path : str
            Path to image directory

        file_format : str
            File format of target scenes

        station_name : str
            Name of target station

        Returns
        ----------
        Dict
            [ year + Julian day : image file path]

        Raises
        ----------
        FileNotFoundError
            If no files match input paramters

        &#34;&#34;&#34;

        path: str = self.path
        station_name: str = self.station_name
        file_format: str = self.file_format
        target_stds: dict = self.stds
        matching_images: dict = {}

        for k, std in target_stds.items():

            user_selection = 0

            year = str(std.year)
            month = buffer_value(std.month, 2)
            day = buffer_value(std.day, 2)
            #  j_day = buffer_value(std.timetuple().tm_yday, 3)
            hour = buffer_value(std.hour, 2)
            minute = buffer_value(std.minute, 2)

            matching_file_list = list(
                glob.iglob(
                    path
                    + f&#34;/{station_name}/{year}/{month}/{day}/*{year + month + day}*{hour + minute}*.{file_format}&#34;
                )
            )

            if not matching_file_list:
                raise FileNotFoundError(
                    f&#34;GROUND image {year}-{month}-{day}-{hour}:{minute} not found&#34;
                )
                # TODO implement match closest
            elif len(matching_file_list) &gt; 1:
                # TODO present use selection
                #  for index, file in enumerate(matching_file_list):
                #     print(f&#34;{index} | {file}&#34;)
                #  user_selection = int(input(&#34;Which file would you like?&#34;))
                raise LookupError(&#34;Multiple matching files found&#34;)

            logging.info(f&#34;GROUND scene {std} found&#34;)

            matching_images[k] = matching_file_list[user_selection]

        return matching_images

    def extract_poi_data(self, image_name: str, image_path: str) -&gt; dict:
        &#34;&#34;&#34;Extract `BI` and `SI` for image at `image_path`.

        Parameters
        ----------
        image_path : str
            path to image `C:\\path\\to\\image`

        Returns
        ----------
        Dict
            [ BI : BI_array, SI : SI_array ]

        &#34;&#34;&#34;

        crop_mask = self.crop_mask

        img_arr = open_image(image_path)

        img = img_arr * crop_mask

        if self.show_images:
            show_image(img)

        if self.save_images:
            img_file_name = image_name + &#34;.png&#34;
            save_image(img_file_name, img.astype(&#34;uint8&#34;))

        img = img.astype(&#34;float&#34;)
        img[img == 0] = np.nan

        R, G, B = extract_color_bands(img)

        SI = calc_SI(R, B)
        BI = calc_BI(R, G, B)

        return {&#34;BI&#34;: BI, &#34;SI&#34;: SI}

    def process_poi_data(self, image_name: str, raw_data: dict) -&gt; dict:
        &#34;&#34;&#34;Process image

        Parameters
        ----------
        raw_data : Dict[ BI : BI_array, SI : SI_array ]
            Dict containing `BI` and `SI` statistics
            as extracted with `extract_poi_data()`

        Returns
        ----------
        Dict: [ BI : BI_stats, SI : SI_stats ]
            Dict with statistics


        &#34;&#34;&#34;

        BI = raw_data[&#34;BI&#34;]
        SI = raw_data[&#34;SI&#34;]

        # we keep NaNs to preserve image shape
        # for reconstitution after cloud mask creation
        # BI = BI[np.logical_not(np.isnan(BI))]
        # SI = SI[np.logical_not(np.isnan(SI))]

        BI_stats: dict = extract_stats(BI)
        SI_stats: dict = extract_stats(SI)
        BI_SI_points = np.column_stack((BI.flatten(), SI.flatten()))

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        boundary = np.column_stack((x_step, y_step))

        pixel_total: int = BI_SI_points[np.logical_not(np.isnan(BI_SI_points))].size / 2

        cloud_mask: list = []
        img_shape: tuple = BI.shape[0:2]
        number_clear: int = 0

        for point in BI_SI_points:
            results: int = f_above_or_below(point, boundary)
            cloud_mask.append(results)
            number_clear = number_clear + results

        cloud_mask = np.array(cloud_mask).reshape(img_shape)

        if self.show_images:
            show_image(cloud_mask)

        if self.save_images:
            img_file_name = image_name + &#34;_cld_mask.png&#34;
            save_image(img_file_name, cloud_mask)

        percent_cloud: float = round(
            ((pixel_total - number_clear) / pixel_total) * 100, 2
        )

        return {
            &#34;BI&#34;: BI_stats,
            &#34;SI&#34;: SI_stats,
            &#34;n_TOTAL&#34;: pixel_total,
            &#34;prcnt_CLD&#34;: percent_cloud,
        }

    def results(self, as_dataframe: Optional[bool] = True):
        &#34;&#34;&#34;Get processed results

        Parameters
        ----------
        as_dataframe : bool
            return as pandas dataframe

        Returns
        ----------
        Dict : dict
            results as Dict

        &#34;&#34;&#34;

        if as_dataframe:
            return pd.DataFrame.from_dict(self.poi, orient=&#34;index&#34;)

        return self.poi

    @staticmethod
    def show_graph(
        poi: dict = None,
        BI=None,
        SI=None,
        save: Optional[bool] = None,
        file_name: Optional[str] = None,
    ):

        if poi:
            BI = poi[&#34;BI&#34;]
            SI = poi[&#34;SI&#34;]
        elif not BI and not SI:
            raise TypeError(&#34;Require poi Dict [&#39;BI&#39; : array, &#39;SI&#39;: array ] or BI / SI&#34;)

        BI = BI.flatten()
        SI = SI.flatten()

        x = BI[np.logical_not(np.isnan(BI))]
        y = SI[np.logical_not(np.isnan(SI))]

        plt.xlabel(&#34;BI&#34;)
        plt.ylabel(&#34;SI&#34;)

        plt.hist2d(x, y, (50, 50), cmap=plt.cm.jet)

        x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
        y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
        plt.plot(x_step, y_step, &#34;w&#34;)

        cb = plt.colorbar()

        if save:
            plt.savefig(file_name, dpi=100)

        # TODO fix
        # one of these works
        cb.remove()
        plt.close()
        plt.close(&#34;all&#34;)
        plt.clf()
        plt.cla()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="skyimage.stations.Ground.Ground.Ground.show_graph"><code class="name flex">
<span>def <span class="ident">show_graph</span></span>(<span>poi: dict = None, BI=None, SI=None, save: Union[bool, NoneType] = None, file_name: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def show_graph(
    poi: dict = None,
    BI=None,
    SI=None,
    save: Optional[bool] = None,
    file_name: Optional[str] = None,
):

    if poi:
        BI = poi[&#34;BI&#34;]
        SI = poi[&#34;SI&#34;]
    elif not BI and not SI:
        raise TypeError(&#34;Require poi Dict [&#39;BI&#39; : array, &#39;SI&#39;: array ] or BI / SI&#34;)

    BI = BI.flatten()
    SI = SI.flatten()

    x = BI[np.logical_not(np.isnan(BI))]
    y = SI[np.logical_not(np.isnan(SI))]

    plt.xlabel(&#34;BI&#34;)
    plt.ylabel(&#34;SI&#34;)

    plt.hist2d(x, y, (50, 50), cmap=plt.cm.jet)

    x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
    y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
    plt.plot(x_step, y_step, &#34;w&#34;)

    cb = plt.colorbar()

    if save:
        plt.savefig(file_name, dpi=100)

    # TODO fix
    # one of these works
    cb.remove()
    plt.close()
    plt.close(&#34;all&#34;)
    plt.clf()
    plt.cla()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="skyimage.stations.Ground.Ground.Ground.extract_poi_data"><code class="name flex">
<span>def <span class="ident">extract_poi_data</span></span>(<span>self, image_name: str, image_path: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Extract <code>BI</code> and <code>SI</code> for image at <code>image_path</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to image <code>C:\path\to\image</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>[ BI : BI_array, SI : SI_array ]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_poi_data(self, image_name: str, image_path: str) -&gt; dict:
    &#34;&#34;&#34;Extract `BI` and `SI` for image at `image_path`.

    Parameters
    ----------
    image_path : str
        path to image `C:\\path\\to\\image`

    Returns
    ----------
    Dict
        [ BI : BI_array, SI : SI_array ]

    &#34;&#34;&#34;

    crop_mask = self.crop_mask

    img_arr = open_image(image_path)

    img = img_arr * crop_mask

    if self.show_images:
        show_image(img)

    if self.save_images:
        img_file_name = image_name + &#34;.png&#34;
        save_image(img_file_name, img.astype(&#34;uint8&#34;))

    img = img.astype(&#34;float&#34;)
    img[img == 0] = np.nan

    R, G, B = extract_color_bands(img)

    SI = calc_SI(R, B)
    BI = calc_BI(R, G, B)

    return {&#34;BI&#34;: BI, &#34;SI&#34;: SI}</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.Ground.Ground.find_matching_images"><code class="name flex">
<span>def <span class="ident">find_matching_images</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Find images matching class variables</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>year</code></strong> :&ensp;<code>str</code></dt>
<dd>Year of target scenes.</dd>
<dt><strong><code>stds</code></strong> :&ensp;<code>dict</code> of <code>str</code></dt>
<dd>Dict of target datetimes</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to image directory</dd>
<dt><strong><code>file_format</code></strong> :&ensp;<code>str</code></dt>
<dd>File format of target scenes</dd>
<dt><strong><code>station_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of target station</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>[ year + Julian day : image file path]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If no files match input paramters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_matching_images(self) -&gt; Dict:
    &#34;&#34;&#34;Find images matching class variables

    Parameters
    ----------
    year : str
        Year of target scenes.

    stds : dict of str
        Dict of target datetimes

    path : str
        Path to image directory

    file_format : str
        File format of target scenes

    station_name : str
        Name of target station

    Returns
    ----------
    Dict
        [ year + Julian day : image file path]

    Raises
    ----------
    FileNotFoundError
        If no files match input paramters

    &#34;&#34;&#34;

    path: str = self.path
    station_name: str = self.station_name
    file_format: str = self.file_format
    target_stds: dict = self.stds
    matching_images: dict = {}

    for k, std in target_stds.items():

        user_selection = 0

        year = str(std.year)
        month = buffer_value(std.month, 2)
        day = buffer_value(std.day, 2)
        #  j_day = buffer_value(std.timetuple().tm_yday, 3)
        hour = buffer_value(std.hour, 2)
        minute = buffer_value(std.minute, 2)

        matching_file_list = list(
            glob.iglob(
                path
                + f&#34;/{station_name}/{year}/{month}/{day}/*{year + month + day}*{hour + minute}*.{file_format}&#34;
            )
        )

        if not matching_file_list:
            raise FileNotFoundError(
                f&#34;GROUND image {year}-{month}-{day}-{hour}:{minute} not found&#34;
            )
            # TODO implement match closest
        elif len(matching_file_list) &gt; 1:
            # TODO present use selection
            #  for index, file in enumerate(matching_file_list):
            #     print(f&#34;{index} | {file}&#34;)
            #  user_selection = int(input(&#34;Which file would you like?&#34;))
            raise LookupError(&#34;Multiple matching files found&#34;)

        logging.info(f&#34;GROUND scene {std} found&#34;)

        matching_images[k] = matching_file_list[user_selection]

    return matching_images</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.Ground.Ground.process_poi_data"><code class="name flex">
<span>def <span class="ident">process_poi_data</span></span>(<span>self, image_name: str, raw_data: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Process image</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>Dict[ BI : BI_array, SI : SI_array ]</code></dt>
<dd>Dict containing <code>BI</code> and <code>SI</code> statistics
as extracted with <code>extract_poi_data()</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Dict</code></strong> :&ensp;<code>[ BI : BI_stats, SI : SI_stats ]</code></dt>
<dd>Dict with statistics</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_poi_data(self, image_name: str, raw_data: dict) -&gt; dict:
    &#34;&#34;&#34;Process image

    Parameters
    ----------
    raw_data : Dict[ BI : BI_array, SI : SI_array ]
        Dict containing `BI` and `SI` statistics
        as extracted with `extract_poi_data()`

    Returns
    ----------
    Dict: [ BI : BI_stats, SI : SI_stats ]
        Dict with statistics


    &#34;&#34;&#34;

    BI = raw_data[&#34;BI&#34;]
    SI = raw_data[&#34;SI&#34;]

    # we keep NaNs to preserve image shape
    # for reconstitution after cloud mask creation
    # BI = BI[np.logical_not(np.isnan(BI))]
    # SI = SI[np.logical_not(np.isnan(SI))]

    BI_stats: dict = extract_stats(BI)
    SI_stats: dict = extract_stats(SI)
    BI_SI_points = np.column_stack((BI.flatten(), SI.flatten()))

    x_step = [0, 0.1, 0.35, 0.7, 0.8, 1]
    y_step = [1, 0.6, 0.35, 0.15, 0.1, 0]
    boundary = np.column_stack((x_step, y_step))

    pixel_total: int = BI_SI_points[np.logical_not(np.isnan(BI_SI_points))].size / 2

    cloud_mask: list = []
    img_shape: tuple = BI.shape[0:2]
    number_clear: int = 0

    for point in BI_SI_points:
        results: int = f_above_or_below(point, boundary)
        cloud_mask.append(results)
        number_clear = number_clear + results

    cloud_mask = np.array(cloud_mask).reshape(img_shape)

    if self.show_images:
        show_image(cloud_mask)

    if self.save_images:
        img_file_name = image_name + &#34;_cld_mask.png&#34;
        save_image(img_file_name, cloud_mask)

    percent_cloud: float = round(
        ((pixel_total - number_clear) / pixel_total) * 100, 2
    )

    return {
        &#34;BI&#34;: BI_stats,
        &#34;SI&#34;: SI_stats,
        &#34;n_TOTAL&#34;: pixel_total,
        &#34;prcnt_CLD&#34;: percent_cloud,
    }</code></pre>
</details>
</dd>
<dt id="skyimage.stations.Ground.Ground.Ground.results"><code class="name flex">
<span>def <span class="ident">results</span></span>(<span>self, as_dataframe: Union[bool, NoneType] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get processed results</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>as_dataframe</code></strong> :&ensp;<code>bool</code></dt>
<dd>return as pandas dataframe</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>results as Dict</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def results(self, as_dataframe: Optional[bool] = True):
    &#34;&#34;&#34;Get processed results

    Parameters
    ----------
    as_dataframe : bool
        return as pandas dataframe

    Returns
    ----------
    Dict : dict
        results as Dict

    &#34;&#34;&#34;

    if as_dataframe:
        return pd.DataFrame.from_dict(self.poi, orient=&#34;index&#34;)

    return self.poi</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skyimage.stations.Ground" href="index.html">skyimage.stations.Ground</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skyimage.stations.Ground.Ground.Ground" href="#skyimage.stations.Ground.Ground.Ground">Ground</a></code></h4>
<ul class="">
<li><code><a title="skyimage.stations.Ground.Ground.Ground.extract_poi_data" href="#skyimage.stations.Ground.Ground.Ground.extract_poi_data">extract_poi_data</a></code></li>
<li><code><a title="skyimage.stations.Ground.Ground.Ground.find_matching_images" href="#skyimage.stations.Ground.Ground.Ground.find_matching_images">find_matching_images</a></code></li>
<li><code><a title="skyimage.stations.Ground.Ground.Ground.process_poi_data" href="#skyimage.stations.Ground.Ground.Ground.process_poi_data">process_poi_data</a></code></li>
<li><code><a title="skyimage.stations.Ground.Ground.Ground.results" href="#skyimage.stations.Ground.Ground.Ground.results">results</a></code></li>
<li><code><a title="skyimage.stations.Ground.Ground.Ground.show_graph" href="#skyimage.stations.Ground.Ground.Ground.show_graph">show_graph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>